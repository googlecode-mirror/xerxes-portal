<?php
// inherits $objRegistry and $objXml
// Converts XML generated by commands to json in a kind of cheesy but convenient
// way. Request parameters force_array_for_key will be passed to
// simple_xml_to_hash to force array output for those keys. 

#header("Content-type: application/json");

//convert to simpleXML, much easier to work with
$objSimpleXML = simplexml_import_dom($objXml->documentElement);

// XML keys (attribute or tag names) that should always be output
// as value arrays, even if they only have one value. Specified
// by caller. 
$forceArray = $objRequest->getProperty("force_array_for_key", true);

// encode_json doesn't deal the way we want with SimpleXML, so we convert
// the xml to a hash the way we want. 
$hash = simple_xml_to_hash($objSimpleXML, $forceArray);

// Remove the "server" info, that's private. 
unset($hash['request']['server']);

// And now convert the hash to json. 
$json = my_json_encode($hash);

echo $json;



// A simplified way of converting a SimpleXML to a hash. Keeps attributes,
// children, and text nodes, but doesn't neccesarily let you tell what
// was an attribute and what was a child, just mashes them all together.
// Obviously not suitable for a 'round trip' back to XML, but convenient. 
// Modelled after ruby's Hash.from_xml
//
// Convert a simpleXML to a hash. Attributes and child nodes are mashed
// together in the same keyspace. If a key name exists in the second argument,
// $force_array, then it's value will always be an array, even if it only has
// one value. Otherwise, the value will only be an array if multiple values,
// otherwise a single value (string or hash). 
//
// If a node has _only_ a text child, that text child will be it's value. 
// If a node has multiple children, text child will be included under key
// '$content'. 
function simple_xml_to_hash($a, $force_array = array('subcategory', 'database')) {
  $hash = array();
  $keyCount = array();
  foreach ($a->attributes() as $name => $value) {
    $key = (string) $name;
    if ( empty($hash[$key])) $hash[$key ]= array();
    array_push($hash[$key], simple_xml_to_hash($value, $force_array)); 
  }
  foreach ($a->children() as $child) {
    $key = (string)$child->getName();
    if ( empty($hash[$key])) $hash[$key ]= array();
    array_push($hash[$key], simple_xml_to_hash($child, $force_array)); 
  }
  // Any arrays of just a single value, make it non-array please. 
  // Unless it was specified as force_array. 
  foreach($hash as $key => $value) {
    if ( (count($value)) == 1 and ! in_array($key, $force_array)   ) $hash[$key] = array_pop($hash[$key]); 
  }
  
  // Add content, either as value in itself, or under $content key in
  // existing hash. 
  if (count(array_keys($hash)) > 0) {
    if (strlen((string)$a) > 0) $hash['$content'] = (string) $a;              
        return $hash;
  }
  else {
    $str = (string) $a;
    //convert booleans and integers. Forget floats. 
    if (in_array( $str , array("true", "y", "yes"))) {
      return true;
    }
    elseif (in_array( $str , array("false", "n", "no")) != FALSE) {
      return false;
    }
    elseif ( preg_match('/^\d+$/', $str)) {
      return (int) $str;
    }
    else {
      return $str;
    }
  }    
}


  // PHP is supposed to have json_encode as an extension, or core in 5.2. but
  // I can't get it to compile, so rolled my own. Could have code check if
  // built in, and define only if not, but I'm not sure if the built in one
  // is completely compatible. 
  //
  // This version of roll-your-own json_encode was found somewhere on
  // php.net comments. 
  function my_json_encode($a=false)
  {
    if (is_null($a)) return 'null';
    if ($a === false) return 'false';
    if ($a === true) return 'true';
    if (is_scalar($a))
    {
      if (is_float($a))
      {
        // Always use "." for floats.
        return floatval(str_replace(",", ".", strval($a)));
      }

      if (is_string($a))
      {
        static $jsonReplaces = array(array("\\", "/", "\n", "\t", "\r", "\b", "\f", '"'), array('\\\\', '\\/', '\\n', '\\t', '\\r', '\\b', '\\f', '\"'));
        return '"' . str_replace($jsonReplaces[0], $jsonReplaces[1], $a) . '"';
      }
      else
        return $a;
    }
    
    $isList = true;
    for ($i = 0, reset($a); $i < count($a); $i++, next($a))
    {
      if (key($a) !== $i)
      {
        $isList = false;
        break;
      }
    }
    $result = array();
    if ($isList)
    {
      foreach ($a as $v) $result[] = my_json_encode($v);
      return '[' . join(',', $result) . ']';
    }
    else
    {
      foreach ($a as $k => $v) $result[] = my_json_encode($k).':'.my_json_encode($v);
      return '{' . join(',', $result) . '}';
    }
  }




1;

?>
